package net.saliman.gradle.plugin.dataextractor

import groovy.sql.Sql
import org.gradle.api.DefaultTask
import org.gradle.api.tasks.TaskAction
import org.gradle.api.tasks.Delete
import org.gradle.api.tasks.Copy
import java.security.AccessController
import java.security.PrivilegedAction

/**
 * Gradle task to extract SQL.
 *
 * @author Steven C. Saliman
 */
class ExtractDataTask extends DefaultTask {
	def String jdbcDriver
	def String jdbcUrl
	def String jdbcUsername
	def String jdbcPassword
	def String[] tables
	def String sqlFilename = "data.sql"
	// Include commit statements?  set to false to generate scripts for LiquiBase
	def includeCommit = true;
	// Include statement to disable foreign keys? Set to true for subsets of data.
	// such as regenerating static-data scripts.
	def disableForeignKeys = false;

	/**
	 * Extract data to a SQL file.
	 */
	@TaskAction
	def extractData() {
		project.logger.info("Extracting data from ${jdbcUrl}")
		if ( tables == null || tables.size() < 1 ) {
			logger.warn("No tables specified. Skipping extraction.")
			return
		}
		// Make sure the driver can be loaded before we try to do anything, then
		// get our database connection.
		Class.forName(jdbcDriver)
		def sql = Sql.newInstance(jdbcUrl, jdbcUsername, jdbcPassword, jdbcDriver)

		// At this point, we're good to go, so we can create (overwrite) the output
		// file.
		def db = dbFromMysqlUrl(jdbcUrl)
		def f = new File(sqlFilename)
		if ( f.exists() ) {
			f.delete()
		}
		f.append("-- This script was generated by the Data Extractor plugin on:\n-- ${new Date()}\n\n")
		project.logger.info("Processing delete statements for ${tables.size()} tables")
		// disable foreign keys.
		if ( disableForeignKeys ) {
			f.append("set foreign_key_checks = 0;\n\n")
		}
		tables.each { table ->
			f.append("delete from ${table};\n\n")
		}
		if ( includeCommit ) {
			f.append("commit;\n\n")
		}

		project.logger.info("Processing table data...")
		tables.reverse(false).each { table ->
			project.logger.info("  processing ${table}:")
			def rowsProcessed = 0
			f.append("\n-- Data for the ${table} table\n")
			def colNames = []
			def columns = []
			def colSql = "select column_name, data_type from information_schema.columns " +
							"where table_schema = '${db}' " +
							"and table_name = '${table}' " +
							"order by ordinal_position"
			sql.eachRow(colSql) { heading ->
				columns << [name: heading.column_name, type: heading.data_type]
				colNames << heading.column_name
			}
			def insertText = "insert into ${table}(" + colNames.join(",") + ")\n"
			sql.eachRow("select " + colNames.join(",") + " from ${table}") { row ->
				def data = []
				columns.each { column ->
					// If we don't have data, use "null", otherwise use the data for the
					// column.  Some column types need to wrap the value in single quotes.
					if ( row[column.name] == null ) {
						data << "null"
					} else  if ( column.type ==~ /.*int/ ) {
						data << row[column.name]
					} else if ( column.type == "decimal" || column.type == "double" ) {
						data << row[column.name]
					} else if ( column.type == "bit" ) {
						data << row[column.name]
					} else {
						data << "'${row[column.name]}'"
					}
				}
				f.append(insertText + "values(" + data.join(",") + ");\n\n", 'UTF-8')
				rowsProcessed++
			}
			if ( includeCommit ) {
				f.append("commit;\n\n")
			}
			project.logger.info("\t${rowsProcessed} rows extracted")
		}
		// Re-enable foreign keys.
		if ( disableForeignKeys ) {
			f.append("set foreign_key_checks = 1;\n\n")
		}

	}

	/**
	 * Helper method to get the database name from a MySql URL, because we need
	 * the database name to get the table metadata.
	 */
	def dbFromMysqlUrl(url) {
		// Strip off the "jdbc:" toget a valid URI
		def newUrl = url.find(~/mysql.*/)
		URI u = new URI(newUrl)
		// Substring to get rid of the leading "/"
		def db = u.getPath().substring(1)
		return db
	}
}
